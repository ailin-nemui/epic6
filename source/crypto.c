/*
 * crypto.c: AES encryption and decryption routines.
 *
 * Copyright (c) 1990 Michael Sandroff.
 * Copyright (c) 1991, 1992 Troy Rollo.
 * Copyright (c) 1992-1996 Matthew Green.
 * Copyright 2006, 2015 EPIC Software Labs
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notices, the above paragraph (the one permitting redistribution),
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The names of the author(s) may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 *	-About AES-256
 *
 * EPIC supports AES-256-cbc in the same format as Cast5-CBC:
 *	PRIVMSG <target> :\001AES256-CBC <payload>\001\r\n
 * except that the <payload> is different:
 *	<Initialization Vector>		A 16-byte random IV (unused by AES)
 *	<Blocks>			Some number of 16 byte blocks
 *	<Final Block>			A final block with up to 15 bytes of
 *					data.  The final byte tells you how 
 *					many bytes should be ignored.
 *
 * The key for AES256 is always 256 bits (32 chars), no matter what.  EPIC 
 * fills short keys with nuls (ie, a password of 5 chars is padded with 27 
 * nuls to fill it out.)  Long keys are truncated at 32 chars.
 */

/*
 *	-About AES-SHA-256
 *
 * EPIC supports AES-SHA-256-cbc in the same format as AES256:
 *	PRIVMSG <target> :\001AESSHA256-CBC <payload>\001\r\n
 * except that the encryption key is generated by taking the sha256 of the
 * key instead of padding it out with nuls (as AES256 does).  This allows
 * an effectively unlimited key length.  
 *
 * Perhaps someday you'll be able to be able to key with a file instead of 
 * a passphrase.
 */

#include "irc.h"
#include "list.h"
#include "sedcrypt.h"
#include "ctcp.h"
#include "ircaux.h"
#include "output.h"
#include "vars.h"
#include "words.h"
#include <openssl/rand.h>

static char *	decipher_evp (const char *passwd, int passwdlen, const char *ciphertext, int cipherlen, const EVP_CIPHER *type, int *outlen, int ivsize);
static char *	cipher_evp (const char *passwd, int passwdlen, const char *plaintext, int plaintextlen, const EVP_CIPHER *type, int *retsize, int ivsize);

/* This function is used by CTCP handling, but not by xform! */
char *	decipher_message (const char *ciphertext, size_t len, List *cryptl, int *retlen)
{
    do
    {
	Crypt *crypti = (Crypt *)(cryptl->d);

	if ( crypti->cipher_type == AES256CRYPT || crypti->cipher_type == AESSHA256CRYPT)
	{
	    char *	outbuf = NULL;
	    const EVP_CIPHER *type;
	    int	bytes_to_trim;
	    int ivsize, blocksize;

	    if (crypti->cipher_type == AES256CRYPT || crypti->cipher_type == AESSHA256CRYPT)
	    {
		ivsize = 16, blocksize = 16;
	    }
	    else
		return NULL;

	    if (blocksize > 0 && len % blocksize != 0)
	    {
		/* 
		 * XXX Sigh, you can't portably printf() a size_t, since 
		 * maybe it's an int, maybe it's a long, and any printf
		 * format that DTRT is too new to trust.  bleh.
		 */
		yell("Encrypted message [%s] isn't multiple of %d! (is %ld)", 
				ciphertext, blocksize, (long)len);
		break;
	    }
	    if ((int)len < blocksize + ivsize)
	    {
		yell("Encrypted message [%s] doesn't contain message! "
				"(len is %ld)", ciphertext, (long)len);
		break;
	    }

	    if (crypti->cipher_type == AES256CRYPT || crypti->cipher_type == AESSHA256CRYPT)
		type = EVP_aes_256_cbc();
	    else
		break;		/* Not supported */

	    if (!(outbuf = decipher_evp(crypti->passwd, crypti->passwdlen,
					ciphertext, len, 
					type, retlen, ivsize)))
	    {
		yell("bummer");
		break;
	    }

	    bytes_to_trim = outbuf[len - 1] & (blocksize - 1);
	    /* outbuf[len - bytes_to_trim - 1] = 0; */
	    outbuf[len - bytes_to_trim] = 0; 
	    memmove(outbuf, outbuf + ivsize, len - ivsize);
	    return (char *)outbuf;
	}
	else
		panic(1, "decipher_message: crypti->cipher_type %d is not valid", crypti->cipher_type);
    }
    while (0);

	return NULL;
}

static char *	decipher_evp (const char *passwd_, int passwdlen, const char *ciphertext_, int cipherlen, const EVP_CIPHER *type, int *outlen, int ivsize)
{
	const unsigned char *passwd = (const unsigned char *)passwd_;
	const unsigned char *ciphertext = (const unsigned char *)ciphertext_;
        unsigned char *outbuf;
	unsigned char	*iv = NULL;
	unsigned long errcode;
	int	outlen2;
        EVP_CIPHER_CTX *context = EVP_CIPHER_CTX_new();

	if (context == NULL) {
		yell("ERROR: Could not generate cipher context");
		return NULL;
	}

	EVP_CIPHER_CTX_set_padding(context, 1);

	if (ivsize > 0)
		iv = new_malloc(ivsize);
	outbuf = new_malloc(cipherlen + 1024);
	if (ivsize > 0)
		memcpy(iv, ciphertext, ivsize);

        EVP_DecryptInit_ex(context, type, NULL, NULL, iv);
	EVP_CIPHER_CTX_set_key_length(context, passwdlen);
	EVP_CIPHER_CTX_set_padding(context, 0);
        EVP_DecryptInit_ex(context, NULL, NULL, passwd, NULL);

        if (EVP_DecryptUpdate(context, outbuf, outlen, ciphertext, cipherlen) != 1)
		yell("EVP_DecryptUpdate died.");
	if (EVP_DecryptFinal_ex(context, outbuf + (*outlen), &outlen2) != 1)
		yell("EVP_DecryptFinal_Ex died.");
	*outlen += outlen2;

        EVP_CIPHER_CTX_free(context);

	ERR_load_crypto_strings();
	while ((errcode = ERR_get_error()))
	{
	    char r[256];
	    ERR_error_string_n(errcode, r, 256);
	    yell("ERROR: %s", r);
	}

	if (ivsize > 0)
		new_free(&iv);
	return (char *)outbuf;
}


/*************************************************************************/
char *	cipher_message (const char *orig_message, size_t len, List *cryptl, int *retlen)
{
	Crypt *	crypti = (Crypt *)(cryptl->d);

	if (retlen)
		*retlen = 0;
	if (!orig_message || !crypti || !retlen)
		return NULL;

	if (crypti->cipher_type == AES256CRYPT || crypti->cipher_type == AESSHA256CRYPT)
	{
	    char *ciphertext = NULL;
	    size_t	ivlen;
	    const EVP_CIPHER *type;

	    if (crypti->cipher_type == AES256CRYPT || crypti->cipher_type == AESSHA256CRYPT)
	    {
		type = EVP_aes_256_cbc();
		ivlen = 16;
	    }
	    else
		return NULL;	/* Not supported */

	    if (!(ciphertext = cipher_evp(crypti->passwd, crypti->passwdlen,
				      orig_message, len, 
				      type, retlen, ivlen)))
	    {
		yell("bummer");
		return NULL;
	    }
	    return (char *)ciphertext;
	}
	else
		panic(1, "cipher_message: crypti->cipher_type %d is not valid", crypti->cipher_type);

	return NULL;
}

static char *	cipher_evp (const char *passwd_, int passwdlen, const char *plaintext_, int plaintextlen, const EVP_CIPHER *type, int *retsize, int ivsize)
{
	const unsigned char *passwd = (const unsigned char *)passwd_;
	const unsigned char *plaintext = (const unsigned char *)plaintext_;
        unsigned char 	*outbuf;
        int     	outlen = 0;
	int		extralen = 0;
	unsigned char	*iv = NULL;
	unsigned long 	errcode;
        EVP_CIPHER_CTX *context = EVP_CIPHER_CTX_new();

	if (context == NULL) 
	{
		yell("ERROR: Could not generate cipher context");
		return NULL;
	}

	EVP_CIPHER_CTX_set_padding(context, 1);

	if (ivsize < 0)
		ivsize = 0;		/* Shenanigans! */

	if (ivsize > 0)
	{
		iv = new_malloc(ivsize);

		/* 
		 * If RAND_bytes() fails, it seems better to use zeroes than to 
		 * leak what was there before...
		 */
		if ((RAND_bytes(iv, ivsize)) <= 0)
			memset(iv, 0, ivsize);
	}

	outbuf = new_malloc(plaintextlen + 100);
	if (iv)
		memcpy(outbuf, iv, ivsize);

        EVP_EncryptInit_ex(context, type, NULL, NULL, iv);
	EVP_CIPHER_CTX_set_key_length(context, passwdlen);
        EVP_EncryptInit_ex(context, NULL, NULL, passwd, NULL);
        EVP_EncryptUpdate(context, outbuf + ivsize, &outlen, plaintext, plaintextlen);
	EVP_EncryptFinal_ex(context, outbuf + ivsize + outlen, &extralen);
        EVP_CIPHER_CTX_free(context);
	outlen += extralen;
	new_free(&iv);

	ERR_load_crypto_strings();
	while ((errcode = ERR_get_error()))
	{
		char r[256];
		ERR_error_string_n(errcode, r, 256);
		yell("ERROR: %s", r);
	}

	*retsize = outlen + ivsize;
	return (char *)outbuf;
}

/**************************************************************************/
static void	ext256_passwd (const char *orig, size_t orig_len, char **passwd, size_t *passwdlen)
{
	size_t	len;

	if (orig_len < 32)
		len = orig_len;
	else
		len = 32;

	*passwd = new_malloc(32);
	memset(*passwd, 0, 32);
	memcpy(*passwd, orig, len);
	*passwdlen = 32;
}

static void	sha256_passwd (const char *orig, size_t orig_len, char **passwd, size_t *passwdlen)
{
	*passwd = new_malloc(34);
	digest(NULL, orig, orig_len, *passwd, 34);
	*passwdlen = 32;
}

static void	copy_passwd (const char *orig, size_t orig_len, char **passwd, size_t *passwdlen)
{
	*passwd = malloc_strdup(orig);
	*passwdlen = orig_len;
}

#if 0
static void 	PBKDF2_HMAC_SHA_512 (const char *pass, uint32_t outputBytes, char* hexResult, uint8_t *binResult)
{
	unsigned int 	i;
	unsigned char 	digest[outputBytes];
	unsigned char	salt[32];
	uint32_t	iterations;

        err = RAND_bytes(salt, sizeof(salt));
        if (err != 1)
                return;
        err = RAND_bytes(&iterations, sizeof(iterations);
        if (err != 1)
                return 0;

	PKCS5_PBKDF2_HMAC(pass, strlen(pass), salt, sizeof(salt), iterations, EVP_sha512(), outputBytes, digest);
	for (i = 0; i < sizeof(digest); i++)
	{
		sprintf(hexResult + (i * 2), "%02x", 255 & digest[i]);
		binResult[i] = digest[i];
	};
}
#endif

/*
 * These are helper functions for $xform() to do SSL strong crypto.
 * XXX These are cut and pasted from decipher_message. 
 */
#define CRYPTO_HELPER_FUNCTIONS(x, y, blocksize, ivsize, make_passwd, trim) \
ssize_t	x ## _encoder (const char *orig, size_t orig_len, const void *meta, size_t meta_len, char *dest, size_t dest_len) \
{ 									\
	int	retsize = 0; 						\
	char *	retval; 						\
	char *realpasswd;						\
	char *	realpasswd_;						\
	size_t	realpasswdlen;						\
									\
	if (orig_len == 0) 						\
	{ 								\
		*dest = 0; 						\
		return 0; 						\
	} 								\
									\
	make_passwd (meta, meta_len, &realpasswd_, &realpasswdlen);	\
	realpasswd = (char *)realpasswd_;				\
	retval = cipher_evp(realpasswd, realpasswdlen, orig, orig_len,	\
				y (), &retsize, ivsize); 		\
	if (retval && retsize > 0) 					\
	{ 								\
		size_t	numb; 						\
		if (dest_len < (size_t)retsize) 			\
			numb = dest_len; 				\
		else 							\
			numb = retsize; 				\
		memcpy(dest, retval, numb); 				\
		dest[numb] = 0; 					\
		new_free(&retval); 					\
		return numb; 						\
	} 								\
									\
	if (retval) 							\
		new_free(&retval); 					\
	new_free(&realpasswd);						\
	return 0; 							\
}									\
									\
ssize_t	x ## _decoder (const char *ciphertext, size_t len, const void *meta, size_t meta_len, char *dest, size_t dest_len) \
{ 														\
	char *	outbuf = NULL; 											\
	int 	retlen = 0; 											\
	char *	realpasswd_;											\
	char *	realpasswd;											\
	size_t	realpasswdlen;											\
														\
	if (len == 0)												\
	{													\
		*dest = 0; 											\
		return 0; 											\
	}													\
														\
	make_passwd (meta, meta_len, &realpasswd_, &realpasswdlen);						\
	realpasswd = (char *)realpasswd_;									\
	if (!(outbuf = decipher_evp(realpasswd, realpasswdlen, ciphertext, len, y (), &retlen, ivsize)))	\
	{ 													\
		yell("bummer"); 										\
		return -1; 											\
	} 													\
														\
	/*													\
	 * Let's talk about padding/trimming...									\
	 *													\
	 * Stock ircII does this thing where it always reserves one more byte than is in the plaintext,		\
	 * before it rounds up to the blocksize.								\
	 *	message of size 7 + extra byte -> 8 -> 1 block of 8 bytes, with a "pad" of 0 (8 - 8)		\
	 *	message of size 8 + extra byte -> 9 -> 2 blocks of 8 bytes, with a "pad" of 7 (16 - 9)		\
	 * The final byte of the final packet is a "pad byte", which indicates how many bytes exist between	\
	 * the end of the message and the "pad byte".  								\
	 *													\
	 * This is fraught because 										\
	 *  (1) It's non-standard, and nobody but ircII does this						\
	 *  (2) OpenSSL just zero-fills pad bytes rather than being clever					\
	 *  (3) There's no way to tell when the message ends if you ignore it!					\
 	 * with the first byte not part of the message and are between 						\
	 * 													\
	 * So what do we do?											\
	 *  (1) Look at the pad byte										\
	 *  (2) If it seems reasonable as a pad value, use it.							\
	 *  (3) If it doesn't seem reasonable, ignore it.							\
	 *  (4) Hope and pray I didn't break anything								\
	 */													\
	if ( trim )												\
	{													\
		int	bytes_to_trim = (int)(unsigned char)outbuf[len - 1];					\
														\
		if (bytes_to_trim == 0)		/* How OpenSSL (and we) do it */				\
		{												\
		}												\
		else if (bytes_to_trim > blocksize)								\
		{												\
			debuglog("Wants to trim %d bytes with block size of %d",				\
				bytes_to_trim, blocksize);							\
			bytes_to_trim = bytes_to_trim % blocksize;						\
		}												\
		outbuf[len - bytes_to_trim] = 0;  								\
		memmove(outbuf, outbuf + ivsize, len - bytes_to_trim); 						\
	}													\
														\
	memcpy(dest, outbuf, retlen); 										\
	dest[retlen] = 0; 											\
	new_free(&outbuf);											\
	return retlen;												\
}

CRYPTO_HELPER_FUNCTIONS(aes, EVP_aes_256_cbc, 16, 16, ext256_passwd, 1)
CRYPTO_HELPER_FUNCTIONS(aessha, EVP_aes_256_cbc, 16, 16, sha256_passwd, 1)

